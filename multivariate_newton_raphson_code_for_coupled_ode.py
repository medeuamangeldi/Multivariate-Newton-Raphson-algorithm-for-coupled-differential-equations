# -*- coding: utf-8 -*-
"""Multivariate Newton-Raphson code for coupled ODE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oQ7bmFYRfb7gN0Ub4YNibd5pPFRA29Z2
"""

import numpy as np
from numpy.linalg import inv
from pylab import *
!pip install symengine
import symengine as se
import sympy as sp

rcParams["figure.figsize"] = (4,3)
matplotlib.rcParams["figure.dpi"] = 300
plt.style.use('seaborn-ticks')
plt.rcParams['xtick.direction'] = 'in'
plt.rcParams['ytick.direction'] = 'in'
matplotlib.rcParams['lines.markersize'] = 10

#symbolic part to quickly derive the partial derivatives
vars = se.symbols('y1_n y2_n y3_n') # Define variables
f = se.sympify(['(1 + 0.04*h)*y1_n - 1e4*h*y2_n*y3_n - y1_0', 'y2_n - h*(0.04*y1_n - 1e4*y2_n*y3_n - 3e7*pow(y2_n,2)) - y2_0', 'y3_n - h*(3e7*pow(y2_n,2)) - y3_0']) # Define functions
J = se.zeros(len(f),len(vars)) 

 # Derive the Jacobian matrix
for i, fi in enumerate(f):
  for j, s in enumerate(vars):
    J[i,j] = se.diff(fi, s)

J

#define the functions
def f1(y1_n, y2_n, y3_n, y1_0, h):
  return (1 + 0.04*h)*y1_n - 1e4*h*y2_n*y3_n - y1_0

def f2(y1_n, y2_n, y3_n, y2_0, h):
  return y2_n - h*(0.04*y1_n - 1e4*y2_n*y3_n - 3e7*pow(y2_n,2)) - y2_0

def f3(y2_n, y3_n, y3_0, h):
  return y3_n - h*(3e7*pow(y2_n,2)) - y3_0

def F(y1_n, y2_n, y3_n, y1_0, y2_0, y3_0, h):

  FM = np.zeros((3,1))
  
  FM[0] = f1(y1_n, y2_n, y3_n, y1_0, h)
  FM[1] = f2(y1_n, y2_n, y3_n, y2_0, h)
  FM[2] = f3(y2_n, y3_n, y3_0, h)

  return FM
  
def J(Y_n, h):

  y1_n = Y_n[0]
  y2_n = Y_n[1]
  y3_n = Y_n[2]

  J = np.zeros((3,3))

  J[0][0] = 1 + 0.04*h
  J[0][1] = -10000.0*h*y3_n
  J[0][2] = -10000.0*h*y2_n

  J[1][0] = -0.04*h
  J[1][1] = 1 - h*(-60000000.0*y2_n - 10000.0*y3_n)
  J[1][2] = 10000.0*h*y2_n

  J[2][1] = -60000000.0*h*y2_n
  J[2][2] = 1
  
  return J

#initial guess for y1, y2, y3 at t = 0
Y_0 = np.zeros((3,1))

Y_0[0] = 1

#constant values
dy = 1e-8
tol = 1e-12
alpha = 1
t_start = 0
t_end = 10*60 #10 minutes
time_space = np.arange(t_start, t_end+0.00001, step = 0.1)
dt = time_space[1] - time_space[0]
N = int(t_end/dt)   #grid size
error_list = [1e-6]*len(time_space) 
err = 1e9 
count = 0
#create column vectors to store the solution values
y1_t = np.ones((N+1,1))
y2_t = np.zeros((N+1,1))
y3_t = np.zeros((N+1,1))

Y_N = np.zeros((3,1))

Y_g = Y_N

for i in range(1, len(time_space)):

  while err >= tol:

    Y_N = Y_g - alpha*np.matmul(inv(J(Y_N, dt)), F(Y_g[0], Y_g[1], Y_g[2], Y_0[0], Y_0[1], Y_0[2], dt))
    
    err = max(abs(Y_N - Y_g))
    
    Y_g = Y_N

    count += 1
  
  error_list[i] = err
  Y_0 = Y_N

  y1_t[i] = Y_N[0]
  y2_t[i] = Y_N[1]
  y3_t[i] = Y_N[2]

  err = 1e9
  count = 1

plot(time_space, y1_t, label = 'y1')
plot(time_space, y2_t, label = 'y2')
plot(time_space, y3_t, label = 'y3')
xlabel('t (s)')
ylabel('Function value')
legend(loc = 'best')
show()

